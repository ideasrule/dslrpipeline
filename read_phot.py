from HATpipepy.Common import Error
from math import log10
from scipy import nan
from string import whitespace
from subprocess import call
from tempfile import NamedTemporaryFile

def flux_to_magnitude(flux, zp=0) :
    """ Returns the magnitude corresponding to the given flux. """

    return nan if flux<=0 else zp - 2.5*log10(flux)

def clean_column_names(dirty_column_names) :
    """ Returns a clean list of column names taking care of names that were
        split because they contained empty spaces. """

    result=[]
    i=0
    while(i<len(dirty_column_names)) :
        if (dirty_column_names[i].startswith('error[')
            and result[-1]=='Flux') :
            result[-1]+='Err['
        elif (dirty_column_names[i]=='error'
            and result[-1]=='Backgr') :
            result[-1]='BGerr'
        elif dirty_column_names[i]=='Background' :
            result.append('BG')
        else : result.append(dirty_column_names[i])
        i+=1
        if result[-1].endswith('[') :
            result[-1]+=dirty_column_names[i]
            i+=1
    return result

def read_fiphot(filename, common_only=False, raw_only=False) :
    """ Reads the human readable photometry files generated by the scripts
    under /S/PROJ/hatuser/201307_D25_vs_T_HS2_test/scripts producing the same
    structure as would be produced by the HATpipey.Common.BinPhot.read_fiphot
    function. """

    f=open(filename, 'r')
    phot=dict(bg=[], source=[], field=[], x=[], y=[], serial=[])
    phot['bg err']=[]
    found_column_names=False
    for lineno, l in enumerate(f) :
        if l[0]=='#' or lineno==0 :
            dirty_column_names=l.lstrip('#').split()
            found_column_names=True
        elif found_column_names :
            found_column_names=False
            column_names=clean_column_names(dirty_column_names)
            bg_col=(column_names.index('BG') if 'BG' in column_names
                    else None)
            id_col=column_names.index('ID')
            bgerr_col=(column_names.index('BGerr') if 'BGerr' in column_names
                       else None)
            y_col=column_names.index('y')
            x_col=column_names.index('x')
            frame_col=(column_names.index('frame') if 'frame' in column_names
                       else None)
            fitted_columns=[]
            per_ap_columns=dict()
            max_ap_ind=0
            for colnum, colname in enumerate(column_names) :
#                print "start" + colname + "end", raw_only, colname.endswith(']')
                if not raw_only and (colname.startswith('sprmag') or
                    colname.startswith('mprmag')) :
 #                   print "wrong if statement!"
                    if colname in phot :
                        raise IOError("Two %s columns found in %s"%
                                      (colname, filename))
                    assert colname not in phot
                    phot[colname]=[]
                    fitted_columns.append((colname, colnum))

                elif colname.endswith(']') :

                    ap_ind=colname[colname.index('[')+1:-1].lstrip('0')
                    if ap_ind=='' : ap_ind=0
                    else : ap_ind=eval(ap_ind)
                    max_ap_ind=max(ap_ind, max_ap_ind)
                    if ap_ind not in per_ap_columns :
                        per_ap_columns[ap_ind]=dict()
                    if colname.startswith('Flux[') :
                        per_ap_columns[ap_ind]['flux']=colnum
                    elif colname.startswith('FluxErr[') :
                        per_ap_columns[ap_ind]['flux error']=colnum
                    elif colname.startswith('S[') or colname.startswith('Flag[') :
                        per_ap_columns[ap_ind]['status']=colnum
                    if not common_only : phot['per aperture']=[
                        {'mag err':[], 'status flag':[], 'mag':[]}
                        for i in range(ap_ind+1)]
        if l[0]!='#' and lineno>0 :
            entries=l.split()
            if bg_col is not None : phot['bg'].append(eval(entries[bg_col]))
            field, source=entries[id_col].split('-')[1:]
            phot['source'].append(eval(source.lstrip('0')))
            phot['field'].append(eval(field.lstrip('0')))
            if bgerr_col is not None :
                phot['bg err'].append(eval(entries[bgerr_col]))
            phot['x'].append(eval(entries[x_col]))
            phot['y'].append(eval(entries[y_col]))
            if frame_col is not None :
                phot['serial'].append(entries[frame_col])
            for colname, colnum in fitted_columns :
		try :
                    phot[colname].append(eval(entries[colnum]))
                except :
                    print "problem with %s:%d column %d"%\
                        (filename, lineno, colnum)
                    raise
            for ap_ind in range(0 if common_only else 
                                len(phot['per aperture'])) :
#                print filename, ap_ind
#                print per_ap_columns[ap_ind]

                flux=eval(entries[per_ap_columns[ap_ind]['flux']])
                flux_err=eval(entries[per_ap_columns[ap_ind]['flux error']])
                    
                mag=flux_to_magnitude(flux)
                dmag=(flux_to_magnitude(flux-flux_err)-
                      flux_to_magnitude(flux+flux_err))
                phot['per aperture'][ap_ind]['mag'].append(mag)
                phot['per aperture'][ap_ind]['mag err'].append(dmag/2.0)
                if ap_ind==len(phot['per aperture'])-1 :
                    if 'status' in per_ap_columns[ap_ind] :
                        status=entries[per_ap_columns[ap_ind]['status']]
                    else :
                        status='G'
                else : status=entries[per_ap_columns[ap_ind]['status']]
                phot['per aperture'][ap_ind]['status flag'].append(
                    (0 if status=='G' else
                     (1 if status=='C' else 2)))
    return phot

def add_columns(filename, new_columns, first_column,
                new_column_width=16) :
    """ Adds the given columns to the file with the given name.

    If first_column is less than the number of columns in the file, columns
    between first_column and first_column+len(new_columns) are overrwitten.
    """

    orig_f=open(filename, 'r')
#    temp_f=open('/data/scratch/w/temp_phot_adding_columns', 'w')
    temp_f=NamedTemporaryFile(dir='/dev/shm/', delete=False)
    
    for lineno, l in enumerate(orig_f) :
        if l.strip()[0]=='#' : 
            num_columns=len(l[1:].split())
            new_column_str=''
            for col_name, col_value, col_precision in new_columns :
                new_column_format=('%-'+str(new_column_width)+'s')
                new_column_str+=(' '+new_column_format)%col_name
            if(first_column==num_columns) :
                temp_f.write(l[:-1]+new_column_str+'\n')
            else :
                end_of_start=1
                for i in range(first_column) :
                    while (end_of_start<len(l) and l[end_of_start] not in
                           whitespace) :
                        end_of_start+=1
                    while (end_of_start<len(l) and l[end_of_start] in
                           whitespace) :
                        end_of_start+=1
                start_of_end=end_of_start
                for i in range(len(new_columns)) :
                    while (start_of_end<len(l) and
                           l[start_of_end] not in whitespace):
                        start_of_end+=1
                    while (start_of_end<len(l) and
                           l[start_of_end] in whitespace) :
                        start_of_end+=1
                temp_f.write(l[:end_of_start]+new_column_str+
                             l[start_of_end:-1]+'\n')
        else :
            column_values=l.split()
            if(first_column>len(column_values)) :
                raise Error.File(('Line %d of %s contains %d columns and '
                                  'adding new columns after %d columns '
                                  'requested.')%
                                 (lineno, filename, len(column_values),
                                  first_column))
            else :
                new_column_str=''
                for col_name, col_values, col_precision in new_columns :
                    new_column_format=('%-'+str(new_column_width)+'.'+
                                       str(col_precision)+'g')
                    new_column_str+=(' '+new_column_format)%\
                            col_values[lineno-1]
                if(first_column==len(column_values)) :
                    temp_f.write(l[:-1]+new_column_str+'\n')
                else :
                    end_of_start=0
                    for i in range(first_column) :
                        while (end_of_start<len(l) and l[end_of_start] not in
                               whitespace) :
                            end_of_start+=1
                        while (end_of_start<len(l) and l[end_of_start] in
                               whitespace) :
                            end_of_start+=1
                    start_of_end=end_of_start
                    for i in range(len(new_columns)) :
                        while (start_of_end<len(l) and
                               l[start_of_end] not in whitespace) :
                            start_of_end+=1
                        while (start_of_end<len(l) and
                               l[start_of_end] in whitespace) :
                            start_of_end+=1
                    temp_f.write(l[:end_of_start]+new_column_str+
                                  l[start_of_end:-1]+'\n')
    orig_f.close()
    temp_f.close()
    call(['mv', temp_f.name, filename])
